# 设计模式

## 为什么要使用设计模式？

设计模式不是代码，而是提供一个在特定情境下解决问题的模版或指南。
使用设计模式可以提高代码的可复用性、可维护性和通信效率

## 基本原则

- 单一职责原则
    - 一个类应该只负责一个职责
    - 定义：一个类应该只负责一项功能或行为，避免一个类承担多个指责
- 开闭原则
    - 对扩展开放，对修改封闭
    - 定义：软件实体（类、模块、函数等）应该对扩展开放，即应该允许在不修改源代码的情况下添加新的功能。同时，这些实体应该对修改封闭，即在不需要修改源代码的情况下可以对功能进行修改或优化
- 里氏替换原则
    - 子类应该能够替换它们的基类
    - 定义：如果S是T的子类，那么应该有T的对象可以用作S的对象，即S应该可以被T替换而不会破坏程序的正确性
- 依赖倒置原则
    - 高层模块不应该依赖于低层模块，二者都应该依赖于抽象
    - 定义：抽象不应该依赖于细节，细节应该依赖于抽象。高层模块和低层模块都应该依赖于抽象层，而不是直接依赖于实现细节
- 接口隔离原则
    - 客户端不应该被迫依赖于它不使用的方法
    - 定义：不应该强迫客户端依赖于它不需要的方法，应该为客户端提供尽可能小的接口
- 迪米特法则
    - 一个对象应该对其他对象保持最少的了解
    - 定义：一个对象应该只和直接相关的对象进行交互，尽量避免对象之间的复杂依赖关系
- 最少知识原则
    - 一个对象应该对其他对象保持最少的了解
    - 定义：一个对象应该只依赖于它需要依赖的信息，不应该依赖于不需要的信息

## 设计模式分类

- Creational Patterns 创建型模式
    - 用于创建对象，减少重复代码的编写
    - 这一类模式关注对象的创建机制，帮助创建对象的过程更加灵活和可控。主要目的是抽象对象的实例过程。
    - Singleton 单例模式
        - 确保一个类只有一个实例，并提供一个全局访问点
    - Factory Method 工厂方法模式
        - 定义一个用于创建对象的接口，让子类决定实例化哪个类
    - Abstract Factory 抽象工厂模式
        - 创建一系列相关或相互依赖的对象，而无需指定它们的具体的类
    - Builder 建造者模式
        - 逐步构造一个复杂对象，允许用户只通过指定复杂对象的类型和内容就可以构建它们
    - Prototype 原型模式
        - 通过复制现有实例来创建新的实例，而不是通过新建
- Structural Patterns 结构型模式
    - 用于处理类和对象的组合，使类和对象的结构更加灵活和清晰
    - 这一类模式关注类和对象的组合，通过继承或者组合来形成更加强大的结构。主要目的是确保系统的各个部分之间的关系和组织。
    - Adapter 适配器模式
        - 允许不兼容的接口之间进行合作
    - Decorator 装饰器模式
        - 动态地给对象添加一些额外职责
    - Proxy 代理模式
        - 为其他对象提供一种代理，以控制对这个对象的访问
    - Facade 外观模式
        - 提供一个统一的接口，用来访问子系统的一群接口
    - Bridge 桥接模式
        - 将抽象部分和实现部分分离，使它们可以独立变化
    - Composite 组合模式
        - 将对象组合成树形结构以表示"部分-整体"的层次结构
    - Flyweight 享元模式
        - 用于大幅度降低复杂对象的内存占用，同时又不失性能
- Behavioral Patterns 行为型模式
    - 用于处理类和对象之间的通信和交互，提高代码的可读性和可维护性
    - Strategy 策略模式
        - 定义一系列算法，把它们一个个封装起来，并使它们可互相替换
    - Command 命令模式
        - 将请求封装成对象，从而允许用户使用不同的请求、队列或者日志来参数化其他对象
    - Chain of Responsibility 职责链模式
        - 为请求创建一个接收者对象的链
    - State 状态模式
        - 允许一个对象在其内部状态改变时改变它的行为
    - Observer 观察者模式
        - 当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动更新
    - Mediator 中介者模式
        - 定义一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使耦合松散，而且可以独立地改变它们之间的交互
    - Iterator 迭代器模式
        - 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示
    - Visitor 访问者模式
        - 表示一个作用于某对象结构中的各元素的操作
    - Memento 备忘录模式
        - 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态
    - Template Method 模版方法模式
        - 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤 
